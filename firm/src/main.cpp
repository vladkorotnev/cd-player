#include "Arduino.h"
#include <WiFi.h>
#include <LittleFS.h>
#include "AudioTools.h"
#include "AudioTools/AudioLibs/AudioSourceLittleFS.h"
#include "AudioTools/AudioCodecs/CodecMP3Helix.h"

#include <esper-core/service.h>
#include <esper-core/platform.h>

#include <esper-cdp/player.h>
#include <esper-cdp/lyrics.h>

#include <esper-gui/hardware/futaba_gp1232.h>
#include <esper-gui/views/framework.h>
#include <esper-gui/compositing.h>

static char LOG_TAG[] = "APL_MAIN";

Core::ThreadSafeI2C * i2c;
Platform::Keypad * keypad;
Platform::IDEBus * ide;
Platform::WM8805 * spdif;
ATAPI::Device * cdrom;
CD::Player * player;
CD::CachingMetadataAggregateProvider * meta;
Graphics::Hardware::FutabaGP1232ADriver * disp;

static TickType_t memory_last_print = 0;
static void print_memory() {
    TickType_t now = xTaskGetTickCount();
    if(now - memory_last_print > pdMS_TO_TICKS(30000)) {
        ESP_LOGI(LOG_TAG, "HEAP: %d free of %d (%d minimum)", ESP.getFreeHeap(), ESP.getHeapSize(), ESP.getMinFreeHeap());
#ifdef BOARD_HAS_PSRAM
        ESP_LOGI(LOG_TAG, "PSRAM: %d free of %d (%d minimum)", ESP.getFreePsram(), ESP.getPsramSize(), ESP.getMinFreePsram());
#endif
        memory_last_print = now;
    }
}

// cppcheck-suppress unusedFunction
void setup(void) { 
#ifdef BOARD_HAS_PSRAM
  heap_caps_malloc_extmem_enable(128);
#endif
  // Open Serial 
  Serial.begin(115200);
  while(!Serial);

  disp = new Graphics::Hardware::FutabaGP1232ADriver();
  disp->initialize();
  disp->set_brightness(Graphics::Hardware::Brightness::DISP_BRIGHTNESS_50);

  Wire.begin(32, 33, 100000);
  i2c = new Core::ThreadSafeI2C(&Wire);
  i2c->log_all_devices();

  LittleFS.begin(true, "/littlefs");
  ESP_LOGI("FS", "Free FS size = %i", LittleFS.totalBytes() - LittleFS.usedBytes());
  
  const uint8_t logo[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x3f, 0xf8, 0x00, 0x00, 0xe0, 0x0f, 0x00, 
    0x03, 0x8f, 0x83, 0x80, 0x06, 0x1f, 0xc0, 0xc0, 0x0c, 0x3f, 0xe0, 0xf0, 0x00, 0x7f, 0xf1, 0xf0, 
    0x00, 0x7f, 0xf3, 0xf8, 0x20, 0x7d, 0xf3, 0xec, 0x00, 0x7d, 0xf1, 0xe4, 0x40, 0x7c, 0xf8, 0x86, 
    0x00, 0x7c, 0xf8, 0x02, 0x80, 0x3e, 0xfe, 0x3b, 0x80, 0x3e, 0xff, 0xfb, 0x80, 0x38, 0x3f, 0xf9, 
    0x00, 0x11, 0x9f, 0xfd, 0x00, 0x1a, 0x5f, 0xf9, 0x00, 0x1a, 0x50, 0x01, 0x00, 0x01, 0x98, 0x01, 
    0x80, 0x38, 0x3f, 0xf9, 0x80, 0x34, 0x7f, 0xfb, 0x00, 0xf8, 0xff, 0xfb, 0x01, 0xfe, 0x1f, 0xfb, 
    0x45, 0xcf, 0x03, 0xe6, 0x0b, 0xdd, 0x00, 0x06, 0x2f, 0x1c, 0x00, 0x0c, 0x17, 0x7e, 0x00, 0x08, 
    0x0b, 0x78, 0x00, 0x18, 0x05, 0xfc, 0x00, 0x10, 0x02, 0xf4, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 
    0x00, 0x28, 0x04, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xe0, 0x00, 
    0x3f, 0xff, 0xe0, 0x00, 0x30, 0x70, 0x60, 0x00, 0x30, 0x20, 0x60, 0x00, 0x30, 0x20, 0x60, 0x00, 
    0x30, 0x20, 0x60, 0x00, 0x30, 0x20, 0x60, 0x00, 0x30, 0x20, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 0xe0, 0x00, 0x1f, 0xc0, 0x60, 0x00, 
    0x18, 0xe0, 0x60, 0x00, 0x30, 0x60, 0x20, 0x00, 0x30, 0x30, 0x20, 0x00, 0x30, 0x38, 0x60, 0x00, 
    0x30, 0x1c, 0xe0, 0x00, 0x30, 0x1f, 0xc0, 0x00, 0x18, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xe0, 0x00, 0x3f, 0xff, 0xe0, 0x00, 
    0x30, 0x18, 0x00, 0x00, 0x30, 0x18, 0x00, 0x00, 0x30, 0x18, 0x00, 0x00, 0x30, 0x18, 0x00, 0x00, 
    0x18, 0x30, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x12, 0x40, 0x00, 0x00, 0x12, 0x40, 0x00, 0x00, 
    0x12, 0x40, 0x00, 0x00, 0x0e, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x01, 0xf8, 
    0x1f, 0xc0, 0x03, 0x2c, 0x18, 0x00, 0x03, 0xbc, 0x10, 0x00, 0x01, 0xbc, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x7c, 
    0x00, 0xfc, 0x00, 0x78, 0x03, 0xff, 0x00, 0x00, 0x0f, 0x87, 0xc0, 0x7c, 0x1c, 0x01, 0xc0, 0x7c, 
    0x18, 0x00, 0xe0, 0x40, 0x18, 0x00, 0x60, 0x7c, 0x30, 0x00, 0x20, 0x7c, 0x30, 0x00, 0x20, 0x00, 
    0x30, 0x00, 0x20, 0x00, 0x30, 0x00, 0x60, 0x02, 0x38, 0x00, 0x62, 0x7e, 0x18, 0x00, 0x42, 0x7e, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xe0, 0x00, 
    0x3f, 0xff, 0xe2, 0x7c, 0x30, 0x00, 0x62, 0x7c, 0x30, 0x00, 0x60, 0x00, 0x30, 0x00, 0x60, 0x00, 
    0x30, 0x00, 0x60, 0x40, 0x18, 0x00, 0x61, 0xfc, 0x18, 0x00, 0xc1, 0xfc, 0x1c, 0x01, 0xc0, 0x44, 
    0x0f, 0x87, 0x80, 0x44, 0x07, 0xff, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6c, 
    0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x5c, 0x3f, 0xff, 0xe0, 0x58, 0x3f, 0xff, 0xe0, 0x00, 
    0x30, 0x18, 0x00, 0x78, 0x30, 0x18, 0x00, 0x7c, 0x30, 0x18, 0x00, 0x04, 0x30, 0x18, 0x00, 0x7c, 
    0x18, 0x30, 0x00, 0x7c, 0x1f, 0xf0, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x03, 0xfc, 0x00, 0x00, 0x03, 0xfc, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 
    0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x5c, 
    0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x03, 0xfc, 0x00, 0x00, 0x03, 0xfc, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x7c, 
    0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6c, 
    0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x5c, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x00
  };

  const uint8_t horz_test[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x02, 0x30, 0x0c, 0x40, 0x05, 0x40, 0x02, 0xa0, 
    0x06, 0x80, 0x01, 0xe0, 0x0f, 0x80, 0x01, 0xf0, 0x0b, 0x00, 0x00, 0xd0, 0x09, 0x00, 0x00, 0x90, 
    0x09, 0x1e, 0x60, 0x90, 0x09, 0x33, 0x58, 0x90, 0x09, 0xa1, 0xcd, 0x90, 0x09, 0xc0, 0xc7, 0x90, 
    0x09, 0x48, 0x52, 0x90, 0x09, 0xc8, 0x13, 0x90, 0x09, 0xc8, 0x13, 0x90, 0x09, 0x62, 0x04, 0x90, 
    0x09, 0x3c, 0x08, 0x90, 0x0b, 0x0f, 0xf0, 0xd0, 0x0b, 0x1e, 0x78, 0xd0, 0x0f, 0x20, 0x04, 0xf0, 
    0x0f, 0x79, 0x1e, 0xf0, 0x0f, 0x58, 0x1a, 0xf0, 0x0f, 0xb1, 0x0d, 0xf0, 0x0b, 0xf2, 0x4f, 0xd0, 
    0x09, 0x9e, 0x79, 0x90, 0x05, 0x7f, 0xfe, 0xa0, 0x02, 0x10, 0x08, 0x40, 0x00, 0x1e, 0x78, 0x00, 
    0x00, 0x1e, 0x78, 0x00, 0x00, 0x1a, 0x68, 0x00, 0x00, 0x0c, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00
  };
  
  Graphics::Compositor *compositor = new Graphics::Compositor(disp);
  UI::View container = UI::View({EGPointZero, {160, 32}});

  auto spinner = std::make_shared<UI::BigSpinner>(UI::BigSpinner({ {142, 4}, {14, 14} }));
  container.subviews.push_back(spinner);

  UI::Image logoimg = {
    .format = EGBufferFormat::EG_FMT_NATIVE,
    .size = {160, 32},
    .data = logo
  };

  UI::Image horztestimg = {
    .format = EGBufferFormat::EG_FMT_HORIZONTAL,
    .size = {32, 32},
    .data = horz_test
  };

  // auto imgview = std::make_shared<UI::ImageView>(UI::ImageView(&logoimg, {{0, 0}, logoimg.size}));
  // container.subviews.push_back(imgview);
  auto mek = std::make_shared<UI::ImageView>(UI::ImageView(&horztestimg, {{0, 0}, horztestimg.size}));
  container.subviews.push_back(mek);


  FILE * f = fopen("/littlefs/font/default.mofo", "rb");
  fseek(f, 0, SEEK_SET);
  Fonts::Font keyrus0808;
  Fonts::Font keyrus0816;
  Fonts::Font xnu;
  Fonts::Font jiskan16;

  if(!Fonts::MoFo::LoadFromHandle(f, &keyrus0808)) ESP_LOGE(LOG_TAG, "keyrus0808 err");
  if(!Fonts::MoFo::LoadFromHandle(f, &keyrus0816)) ESP_LOGE(LOG_TAG, "keyrus0816 err");
  if(!Fonts::MoFo::LoadFromHandle(f, &xnu)) ESP_LOGE(LOG_TAG, "xnu err");
  fclose(f);

  if(!Fonts::MoFo::Load("/littlefs/font/misaki_mincho.mofo", &jiskan16)) ESP_LOGE(LOG_TAG, "jiskan err");

  auto lbl = std::make_shared<UI::Label>(UI::Label({{32, 0}, {100, 16}}, &xnu, "I'm Miku oo-ee-oo"));
  container.subviews.push_back(lbl);

  auto lbl2 = std::make_shared<UI::Label>(UI::Label({{32, 16}, {100, 16}}, &jiskan16, "世界で一番のお姫様"));
  container.subviews.push_back(lbl2);

  Platform::Nixierator nixie(i2c);
  nixie.leading_zero = true;

  TickType_t fps_lock = xTaskGetTickCount();
  TickType_t second = xTaskGetTickCount();
  int i = 0;
  bool miku_dir = false;
  while(true) {
    print_memory();

    TickType_t now = xTaskGetTickCount();
    if(now - second >= pdMS_TO_TICKS(1000)) {
      i = (i + 1) % 100;
      lbl->set_value("I'm Miku " + std::to_string(i));
      nixie.set_value(i);
      second = now;
    }

    if(miku_dir) {
      mek->frame.origin.y += 1;
      if(mek->frame.origin.y == 1) miku_dir = false;
    } else {
      mek->frame.origin.y -= 1;
      if(mek->frame.origin.y == -4) miku_dir = true;
    }
    compositor->render(container);
    xTaskDelayUntil(&fps_lock, pdMS_TO_TICKS(16)); // one frame every 16ms roughly
  }

  WiFi.begin(WIFI_NAME, WIFI_PASS);
  WiFi.waitForConnectResult();
  if(WiFi.isConnected()) Serial.println("WiFi ok");
  else Serial.println("!! WIFI FAIL !!");

  Core::Services::NTP::start();

  spdif = new Platform::WM8805(i2c);
  spdif->initialize();
  spdif->set_enabled(true);

  pinMode(18 /* #mute */, OUTPUT);
  pinMode(26 /* deemph */, OUTPUT);
  digitalWrite(18, false); // set mute
  digitalWrite(26, false); // no deemph

  // release i2s bus by setting hi-Z
  pinMode(3 /* mck */, INPUT);
  digitalWrite(3, LOW);
  pinMode(27 /* data */, INPUT);
  digitalWrite(27, LOW);

  keypad = new Platform::Keypad(i2c);
  ide = new Platform::IDEBus(i2c);
  cdrom = new ATAPI::Device(ide);

  meta = new CD::CachingMetadataAggregateProvider("/littlefs");
  meta->providers.push_back(new CD::CDTextMetadataProvider());
  meta->providers.push_back(new CD::MusicBrainzMetadataProvider());
  meta->providers.push_back(new CD::CDDBMetadataProvider("gnudb.gnudb.org", "asdfasdf@example-esp32.com"));
  meta->providers.push_back(new CD::LrcLibLyricProvider());
  
  player = new CD::Player(cdrom, meta);
}

uint8_t kp_sts = 0;

CD::Player::State last_sts;
MSF last_msf;
CD::Player::TrackNo last_trkno;
int last_lyric_idx = -1;

// cppcheck-suppress unusedFunction
void loop() {
  // TBD: Maybe use motor control peripheral for this instead of software?
  digitalWrite(18, spdif->locked_on()); // only unmute when SPDIF locked

  print_memory();

  CD::Player::State sts = player->get_status();
  if(sts != last_sts) {
    ESP_LOGI("Test", "State %s -> %s", CD::Player::PlayerStateString(last_sts), CD::Player::PlayerStateString(sts));
    last_sts = sts;
  }
  
  MSF msf = player->get_current_track_time();

  CD::Player::TrackNo trk = player->get_current_track_number();
  if(trk.track != last_trkno.track || trk.index != last_trkno.index) {
    ESP_LOGI("Test", "Trk#: %i.%i -> %i.%i", last_trkno.track, last_trkno.index, trk.track, trk.index);
    last_lyric_idx = -1;
    auto slot = player->get_active_slot();

    if(trk.track <= slot.disc->tracks.size() && trk.index == 1) {
      auto meta = slot.disc->tracks[trk.track - 1];
      if(meta.title != "") {
        ESP_LOGI("Test", "... -> %s - %s", meta.artist.c_str(), meta.title.c_str());
      }
    }

    ESP_LOGI("Test", "SPDIF is %s", spdif->locked_on() ? "lock" : "UN LOCK !!");
    last_trkno = trk;
  }

  if((msf.M != last_msf.M || msf.S != last_msf.S || msf.F != last_msf.F) && trk.index == 1) {
    auto slot = player->get_active_slot();
    if(trk.track <= slot.disc->tracks.size()) {
      auto meta = slot.disc->tracks[trk.track - 1];
      if(!meta.lyrics.empty()) {
        int cur_ms = MSF_TO_MILLIS(msf);
        int idx = last_lyric_idx;
        for(int i = 0; i < meta.lyrics.size(); i++) {
          if(meta.lyrics[i].millisecond <= cur_ms && meta.lyrics[i + 1].millisecond > cur_ms) {
            idx = i;
            break;
          }
        }
        if(idx != last_lyric_idx && idx != -1) {
          last_lyric_idx = idx;
          ESP_LOGI("Lyric", " %i | %i | e=%i\t -= %s =- ", cur_ms, meta.lyrics[idx].millisecond, (cur_ms - meta.lyrics[idx].millisecond), meta.lyrics[idx].line.c_str());
        }
      }
    }
  }

  uint8_t kp_new_sts = 0;
  if(keypad->read(&kp_new_sts)) {
    if(kp_new_sts != kp_sts) {
      ESP_LOGI("Test", "Key change: 0x%02x to 0x%02x", kp_sts, kp_new_sts);
      kp_sts = kp_new_sts;
      
      if(kp_sts == 1) {
        player->do_command(CD::Player::Command::OPEN_CLOSE);
      }
      else if(kp_sts == 2) {
        player->do_command(CD::Player::Command::PLAY_PAUSE);
      }
      else if(kp_sts == 4) { 
        player->do_command(CD::Player::Command::PREV_TRACK);
      }
      else if(kp_sts == 8) { 
        player->do_command(CD::Player::Command::NEXT_TRACK);
      }
      else if(kp_sts == 16) { 
        player->do_command(CD::Player::Command::PREV_DISC);
      }
      else if(kp_sts == 32) {
        player->do_command(CD::Player::Command::NEXT_DISC);
      }
      else if(kp_sts == 64) {
        player->do_command(CD::Player::Command::SEEK_FF);
      }
      else if(kp_sts == 128) {
        player->do_command(CD::Player::Command::END_SEEK);
      }
    }
  }
}